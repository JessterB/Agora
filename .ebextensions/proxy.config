###################################################################################################
#### Copyright 2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
####
#### Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file
#### except in compliance with the License. A copy of the License is located at
####
####     http://aws.amazon.com/apache2.0/
####
#### or in the "license" file accompanying this file. This file is distributed on an "AS IS"
#### BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#### License for the specific language governing permissions and limitations under the License.
###################################################################################################

###################################################################################################
#### This configuration file configures Nginx for Node.js environments to redirect HTTP
#### requests on port 80 to HTTPS on port 443 after you have configured your environment to support
#### HTTPS connections:
####
#### Configuring Your Elastic Beanstalk Environment's Load Balancer to Terminate HTTPS:
####  http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/configuring-https-elb.html
####
#### Terminating HTTPS on EC2 Instances Running Node.js:
####  http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/https-singleinstance-nodejs.html
###################################################################################################
files:
  /etc/nginx/conf.d/proxy.conf:
    mode: "000644"
    owner: root
    group: root
    content: |
      upstream nodejs {
        server 127.0.0.1:8080;
        keepalive 256;
      }

      http {
        # The processing rate of requests coming from a single IP address
        # Create a rule to be used on defined server locations defined below inside "server {...}"
        limit_req_zone $binary_remote_addr zone=one:10m rate=3000r/s;

        # Allow X Connections per an IP address at a time
        # It is individually defined below inside "server {...}" for each location
        limit_conn_zone $binary_remote_addr zone=addr:10m;

        # Timeout for HTTP keep-alive connections
        #
        # https://en.wikipedia.org/wiki/HTTP_persistent_connection
        keepalive_timeout 300;
        keepalive_requests 100000; # Amount of keep-alive connections to allow at a time

        # Allows using sendfile() to transfer data directly in the kernel space
        # http://nginx.org/en/docs/http/ngx_http_core_module.html#sendfile
        sendfile off;
        tcp_nopush on;    # Allows sending a file in full packets in FreeBSD & Linux
        tcp_nodelay on;   # Forces sockets to send the data they have in their buffer

        # Sets buffer size for reading client request body.
        # In case the request body is larger than the buffer, the whole body or only its part is written to a temporary file
        client_body_buffer_size      128k;

        # Allow a maximum body size of the client request (specified in the “Content-Length” request header field)
        client_max_body_size         10m;

        # Allow up to this buffer size for reading client request headers. For most requests, a buffer of 1K bytes is enough
        client_header_buffer_size    1k;

        # A request line cannot exceed the size of one buffer, or the 414 (Request-URI Too Large) error is returned to the client
        large_client_header_buffers  4 4k;

        server {
            listen 80;

            if ($time_iso8601 ~ "^(\d{4})-(\d{2})-(\d{2})T(\d{2})") {
                set $year $1;
                set $month $2;
                set $day $3;
                set $hour $4;
            }
            access_log /var/log/nginx/healthd/application.log.$year-$month-$day-$hour healthd;
            access_log  /var/log/nginx/access.log  main;

            location / {
                try_files $uri $uri/ /index.html =404;
                expires       0;
                add_header    Cache-Control  public;
                add_header    Cache-Control  no-store;
                add_header    Cache-Control  no-cache;

                aio on;
                directio 512;
                output_buffers 1 8m;

                set $redirect 0;
                if ($http_x_forwarded_proto != "https") {
                    set $redirect 1;
                }
                if ($http_user_agent ~* "ELB-HealthChecker") {
                    set $redirect 0;
                }
                if ($redirect = 1) {
                    return 301 https://$host$request_uri;
                }

                proxy_pass  http://nodejs;
                proxy_set_header   Connection "";
                proxy_http_version 1.1;
                proxy_set_header        Host               $host;
                proxy_set_header        X-Real-IP          $remote_addr;
                proxy_set_header        X-Forwarded-For    $proxy_add_x_forwarded_for;
                proxy_set_header        X-Forwarded-For    $proxy_add_x_forwarded_for;
                proxy_set_header        X-Forwarded-Proto  $scheme;

                # Tell the upstream servers that the request was proxied through NGINX, no specific use case but can be useful
                proxy_set_header   X-NginX-Proxy    true;

                # When one of the replicated server is down (e.g if the container is being updated with the latest version and coming back up soon)
                # NGINX will only wait for 2 seconds to connect to it, and if not successful, will move on to another one
                proxy_connect_timeout      2;
                proxy_buffer_size          8k;
                proxy_buffers              8 32k;
                proxy_busy_buffers_size    64k;
                proxy_temp_file_write_size 64k;
                proxy_temp_path            /etc/nginx/proxy_temp;
            }

            # Hide the NGINX version on error pages and in the “Server” response header field
            server_tokens   off;

            # Enable gzip compression of static files
            gzip on;

            # Disable gzip for Internet Explorer v1-6
            gzip_disable "MSIE [1-6]\.";

            # Sets a gzip compression level of a response. Acceptable values are in the range from 1 to 9 (higher value means more compression)
            # Level 5 is very common
            gzip_comp_level 9;

            # Depending on if gzip is supported by the client's browser, they either receive a compressed version of the file or an uncompressed one
            # Now if a compressed version is cached, and the browser does not support that, NGINX wouldn't know to lookup the origin
            # If the Vary header isn't in there, and might serve an unsupported file to the client
            gzip_vary on;

            # Sets the minimum length of a response that will be gzipped, determined only from the “Content-Length” response header field.
            gzip_min_length 1000;

            # Enables or disables gzipping of responses for proxied requests depending on the request and response
            gzip_proxied any;

            # Filetypes that would be gzipped, if the client's browser accepts encoding, and the file length is larger than the gzip_min_length above
            gzip_types application/x-javascript text/css application/javascript text/javascript text/plain text/xml application/json application/vnd.ms-fontobject application/x-font-opentype application/x-font-truetype application/x-font-ttf application/xml font/eot font/opentype font/otf image/svg+xml image/vnd.microsoft.icon;

            # Sets the number and size of buffers used to compress a response. By default, the buffer size is equal to one memory page.
            # This is either 4K or 8K, depending on a platform.
            gzip_buffers 16 8k;

            limit_rate_after 2m;
            limit_rate 100k;
        }
      }

  /opt/elasticbeanstalk/hooks/configdeploy/post/99_kill_default_nginx.sh:
    mode: "000755"
    owner: root
    group: root
    content: |
      #!/bin/bash -xe
      if [ -f /etc/nginx/conf.d/00_elastic_beanstalk_proxy.conf ]; then rm -f /etc/nginx/conf.d/00_elastic_beanstalk_proxy.conf; fi
      echo 'Stopping Nginx......'
      initctl stop nginx
      echo 'Starting Nginx...... '
      initctl start nginx

container_commands:
 removeconfig:
    command: "rm -f /tmp/deployment/config/#etc#nginx#conf.d#00_elastic_beanstalk_proxy.conf /etc/nginx/conf.d/00_elastic_beanstalk_proxy.conf"
